ggplot(aes(x=submitter_condition, y=mean_rating, fill=submitter_condition)) +
geom_boxplot(position=position_dodge()) +
stat_summary(fun = "mean") +
facet_wrap(~metric)
individual_ratings %>%
group_by(subset_ids_DO, metric) %>%
summarize(mean_rating = mean(rating_num)) %>%
ggplot(aes(x=submitter_condition, y=mean_rating, fill=submitter_condition)) +
geom_boxplot(stat="identity",
position=position_dodge()) +
stat_summary(fun = "mean") +
facet_wrap(~metric)
individual_ratings %>%
# 1. Aggregate to the person level
# We group by ID, Metric, AND Condition to preserve the condition label
group_by(subset_ids_DO, metric, submitter_condition) %>%
summarize(person_mean = mean(rating_num, na.rm = TRUE), .groups = "drop") %>%
# 2. Plot the distribution of the person-means
ggplot(aes(x = submitter_condition, y = person_mean, fill = submitter_condition)) +
geom_boxplot() +
facet_wrap(~metric) +
theme_minimal() +
labs(y = "Mean Rating (per person)")
individual_ratings %>%
# 1. Aggregate to the person level
# We group by ID, Metric, AND Condition to preserve the condition label
group_by(subset_ids_DO, metric, submitter_condition) %>%
summarize(person_mean = mean(rating_num, na.rm = TRUE), .groups = "drop") %>%
# 2. Plot the distribution of the person-means
ggplot(aes(x = submitter_condition, y = person_mean, fill = submitter_condition)) +
geom_boxplot() +
facet_wrap(~metric) +
theme_minimal() +
stat_summary(fun="mean") +
labs(y = "Mean Rating (per person)") +
scale_fill_manual(values = c("control" = "#619bff", "high-agency" = "#00BA38", "low-agency" = "#F8766D", "unstructured" = "gold"))
individual_ratings <- rbind(condition_ratings, condition_ratings_2) %>%
select(subset_ids_DO, trial_id:submitter_condition) %>%
rename(subset_id = subset_ids_DO)
individual_ratings %>%
# 1. Aggregate to the person level
# We group by ID, Metric, AND Condition to preserve the condition label
group_by(subset_id, metric, submitter_condition) %>%
summarize(person_mean = mean(rating_num, na.rm = TRUE), .groups = "drop") %>%
# 2. Plot the distribution of the person-means
ggplot(aes(x = submitter_condition, y = person_mean, fill = submitter_condition)) +
geom_boxplot() +
facet_wrap(~metric) +
theme_minimal() +
stat_summary(fun="mean") +
labs(y = "Mean Rating (per person)") +
scale_fill_manual(values = c("control" = "#619bff", "high-agency" = "#00BA38", "low-agency" = "#F8766D", "unstructured" = "gold"))
# Get the idea subsets that were still not rated after 2nd round
unrated_2 <- master_df %>%
anti_join(individual_ratings, by="subset_id")
View(unrated_2)
write_csv(unrated_2, "data/unrated2.csv")
ratings_3 <- fetch_survey("SV_1NR8ooZcp8qTtZQ",
label = TRUE,
convert = FALSE,
breakout_sets = FALSE)
old_numbers <- 309:314
new_numbers <- c(15, 26, 88, 193, 211, 230)
# Check: Ensure both lists are the same length (should be 52)
if(length(new_numbers) != length(old_numbers)) {
stop("Error: The number of new IDs does not match the number of old IDs.")
}
# 3. Rename columns so they match the master df
for (i in seq_along(old_numbers)) {
# Define the pattern: starts with (^) the old number
pattern <- paste0("^", old_numbers[i])
# Define the replacement: the corresponding new number
replacement <- as.character(new_numbers[i])
# Update column names
names(ratings_3) <- sub(pattern, replacement, names(ratings_3))
}
View(ratings_3)
ratings_3_long <- ratings_3 %>%
pivot_longer(cols =15:284,
names_to = "rater_trial",
values_to = "rating") %>%
drop_na(rating) %>%
mutate(rating_num = as.numeric(str_extract(rating, "\\d"))) %>%
extract(
col = rater_trial,
into = c("trial_id", "metric"),
# Regex Explanation:
# ^(.*)    -> Capture everything from the start...
# _        -> ...until the very last underscore...
# ([^_]+)$ -> ...and capture the final chunk (the metric) separately.
regex = "^(.*)_([^_]+)$"
)
View(ratings_3_long)
ratings_3 <- fetch_survey("SV_1NR8ooZcp8qTtZQ",
label = TRUE,
convert = FALSE,
breakout_sets = FALSE)
old_numbers <- 309:314
new_numbers <- c(15, 26, 88, 193, 211, 230)
# Check: Ensure both lists are the same length (should be 52)
if(length(new_numbers) != length(old_numbers)) {
stop("Error: The number of new IDs does not match the number of old IDs.")
}
# 3. Rename columns so they match the master df
for (i in seq_along(old_numbers)) {
# Define the pattern: starts with (^) the old number
pattern <- paste0("^", old_numbers[i])
# Define the replacement: the corresponding new number
replacement <- as.character(new_numbers[i])
# Update column names
names(ratings_3) <- sub(pattern, replacement, names(ratings_3))
}
ratings_3_long <- ratings_3 %>%
pivot_longer(cols =15:284,
names_to = "rater_trial",
values_to = "rating") %>%
drop_na(rating) %>%
mutate(rating_num = as.numeric(str_extract(rating, "\\d"))) %>%
extract(
col = rater_trial,
into = c("trial_id", "metric"),
# Regex Explanation:
# ^(.*)    -> Capture everything from the start...
# _        -> ...until the very last underscore...
# ([^_]+)$ -> ...and capture the final chunk (the metric) separately.
regex = "^(.*)_([^_]+)$"
)
unique(ratings_3_long$subset_ids_DO)
condition_ratings_3 <- left_join(ratings_3_long, decoder_key, by="trial_id")
# Bind rows
individual_ratings <- rbind(individual_ratings, condition_ratings_3) %>%
select(subset_id, trial_id:submitter_condition)
View(condition_ratings_3)
condition_ratings_3 <- left_join(ratings_3_long, decoder_key, by="trial_id") %>%
rename(subset_id = "subset_ids_DO") %>%
select(subset_id, trial_id_submitter_condition)
# Bind rows
all_ratings <- rbind(individual_ratings, condition_ratings_3)
condition_ratings_3 <- left_join(ratings_3_long, decoder_key, by="trial_id") %>%
rename(subset_id = "subset_ids_DO") %>%
select(subset_id, trial_id:submitter_condition)
# Bind rows
all_ratings <- rbind(individual_ratings, condition_ratings_3)
ratings_3 <- fetch_survey("SV_1NR8ooZcp8qTtZQ",
label = TRUE,
convert = FALSE,
breakout_sets = FALSE)
old_numbers <- 309:314
new_numbers <- c(15, 26, 88, 193, 211, 230)
# Check: Ensure both lists are the same length (should be 52)
if(length(new_numbers) != length(old_numbers)) {
stop("Error: The number of new IDs does not match the number of old IDs.")
}
# 3. Rename columns so they match the master df
for (i in seq_along(old_numbers)) {
# Define the pattern: starts with (^) the old number
pattern <- paste0("^", old_numbers[i])
# Define the replacement: the corresponding new number
replacement <- as.character(new_numbers[i])
# Update column names
names(ratings_3) <- sub(pattern, replacement, names(ratings_3))
}
ratings_3_long <- ratings_3 %>%
pivot_longer(cols =15:284,
names_to = "rater_trial",
values_to = "rating") %>%
drop_na(rating) %>%
mutate(rating_num = as.numeric(str_extract(rating, "\\d"))) %>%
extract(
col = rater_trial,
into = c("trial_id", "metric"),
# Regex Explanation:
# ^(.*)    -> Capture everything from the start...
# _        -> ...until the very last underscore...
# ([^_]+)$ -> ...and capture the final chunk (the metric) separately.
regex = "^(.*)_([^_]+)$"
)
length(unique(ratings_3_long$subset_ids_DO))
condition_ratings_3 <- left_join(ratings_3_long, decoder_key, by="trial_id") %>%
rename(subset_id = "subset_ids_DO") %>%
select(subset_id, trial_id:submitter_condition)
# Bind rows
all_ratings <- rbind(individual_ratings, condition_ratings_3)
plot_data <- all_ratings %>%
filter(metric %in% c("creative", "original", "useful")) %>%
group_by(metric, submitter_condition) %>%
get_summary_stats(rating_num, type = "mean_ci")
all_ratings %>%
# 1. Aggregate to the person level
# We group by ID, Metric, AND Condition to preserve the condition label
group_by(subset_id, metric, submitter_condition) %>%
summarize(person_mean = mean(rating_num, na.rm = TRUE), .groups = "drop") %>%
# 2. Plot the distribution of the person-means
ggplot(aes(x = submitter_condition, y = person_mean, fill = submitter_condition)) +
geom_boxplot() +
facet_wrap(~metric) +
theme_minimal() +
stat_summary(fun="mean") +
labs(y = "Mean Rating (per person)") +
scale_fill_manual(values = c("control" = "#619bff", "high-agency" = "#00BA38", "low-agency" = "#F8766D", "unstructured" = "gold"))
# 2. Plot with Error Bars
ggplot(plot_data, aes(x = submitter_condition, y = mean, fill = submitter_condition)) +
geom_bar(stat = "identity", position = position_dodge(), alpha = 0.7) +
geom_errorbar(aes(ymin = mean - se, ymax = mean + se),
width = 0.2,
position = position_dodge(0.9)) +
facet_wrap(~ metric) +  # Creates 3 side-by-side panels
theme_minimal() +
labs(title = "Ratings by Condition (Mean +/- SE)",
y = "Average Rating",
x = "Condition") +
scale_fill_manual(values = c("control" = "#619bff", "high-agency" = "#00BA38", "low-agency" = "#F8766D", "unstructured" = "gold")) +
jtools::theme_apa()
ratings_3 <- fetch_survey("SV_1NR8ooZcp8qTtZQ",
label = TRUE,
convert = FALSE,
breakout_sets = FALSE)
old_numbers <- 309:314
new_numbers <- c(15, 26, 88, 193, 211, 230)
# Check: Ensure both lists are the same length (should be 52)
if(length(new_numbers) != length(old_numbers)) {
stop("Error: The number of new IDs does not match the number of old IDs.")
}
# 3. Rename columns so they match the master df
for (i in seq_along(old_numbers)) {
# Define the pattern: starts with (^) the old number
pattern <- paste0("^", old_numbers[i])
# Define the replacement: the corresponding new number
replacement <- as.character(new_numbers[i])
# Update column names
names(ratings_3) <- sub(pattern, replacement, names(ratings_3))
}
ratings_3_long <- ratings_3 %>%
pivot_longer(cols =15:284,
names_to = "rater_trial",
values_to = "rating") %>%
drop_na(rating) %>%
mutate(rating_num = as.numeric(str_extract(rating, "\\d"))) %>%
extract(
col = rater_trial,
into = c("trial_id", "metric"),
# Regex Explanation:
# ^(.*)    -> Capture everything from the start...
# _        -> ...until the very last underscore...
# ([^_]+)$ -> ...and capture the final chunk (the metric) separately.
regex = "^(.*)_([^_]+)$"
)
condition_ratings_3 <- left_join(ratings_3_long, decoder_key, by="trial_id") %>%
rename(subset_id = "subset_ids_DO") %>%
select(subset_id, trial_id:submitter_condition)
# Bind rows
all_ratings <- rbind(individual_ratings, condition_ratings_3)
View(all_ratings)
all_ratings_wide <- all_ratings %>%
pivot_wider(names_from = "metric",
values_from = "rating_num")
all_ratings_wide <- all_ratings %>%
pivot_wider(id_cols = "trial_id",
names_from = "metric",
values_from = "rating_num")
View(all_ratings_wide)
condition_ratings_3 <- left_join(ratings_3_long, decoder_key, by="trial_id") %>%
rename(subset_id = "subset_ids_DO") %>%
select(participantId, subset_id, trial_id:submitter_condition)
individual_ratings <- rbind(condition_ratings, condition_ratings_2) %>%
select(participantId, subset_ids_DO, trial_id:submitter_condition) %>%
rename(subset_id = subset_ids_DO)
# Bind rows
all_ratings <- rbind(individual_ratings, condition_ratings_3)
all_ratings_wide <- all_ratings %>%
pivot_wider(id_cols = c("participantId", "trial_id"),
names_from = "metric",
values_from = "rating_num")
View(all_ratings_wide)
?pivot_wider
all_ratings_wide <- all_ratings %>%
pivot_wider(
names_from = "metric",
values_from = "rating_num")
View(all_ratings_wide)
all_ratings_wide <- all_ratings %>%
pivot_wider(
names_from = "metric",
values_from = "rating_num") %>%
drop_na(creative, original, useful)
length(unique(all_ratings_wide$subset_id))
all_ratings_wide <- all_ratings %>%
pivot_wider(
names_from = "metric",
values_from = "rating_num")
length(unique(all_ratings_wide$subset_id))
all_ratings_wide <- all_ratings %>%
select(-rating) %>%
pivot_wider(
names_from = "metric",
values_from = "rating_num")
View(all_ratings_wide)
all_ratings_wide <- all_ratings %>%
select(-rating) %>%
pivot_wider(
names_from = "metric",
values_from = "rating_num")
length(unique(all_ratings_wide$subset_id))
View(df_processed_demographics)
all_ratings_demographics <- left_join(all_ratings_wide, df_processed_demographics, by="trial_id")
View(demographics)
View(df_processed_demographics)
View(all_ratings_wide)
all_ratings_demographics <- full_join(all_ratings_wide, df_processed_demographics, by=c("trial_id"))
View(all_ratings_demographics)
all_ratings_demographics <- full_join(all_ratings_wide, df_processed_demographics)
View(all_ratings_demographics)
all_ratings_demographics <- full_join(all_ratings_wide, df_processed_demographics) %>%
drop_na(submitter_id)
all_ratings_demographics <- left_join(all_ratings_wide, df_processed_demographics)
View(all_ratings_demographics)
all_ratings_demographics <- left_join(all_ratings_wide, df_processed_demographics) %>%
group_by(subset_id) %>%
# List the columns to fill
fill(submitter_id:age, .direction = "downup") %>%
ungroup()
all_ratings_demographics <- left_join(all_ratings_wide, df_processed_demographics)
View(decoder_key)
View(master_df)
decoder_key <- master_df %>%
# --- Step A: Rename "Idea" columns to match the pattern ---
# matches("^[a-z]+_\\d+$") finds columns like 'brick_1' but ignores 'brick_1_Condition'
rename_with(
.fn = ~paste0(., "_Text"),
.cols = matches("^[a-z]+_\\d+$")
) %>%
# --- Step B: Pivot everything at once ---
# We use a regex pattern to split the column names into 3 parts:
# 1. Object (brick)  2. Digit (1)  3. Type (Text or Condition)
pivot_longer(
cols = -subset_id,
names_to = c("object", "digit", ".value"),
names_pattern = "(.*)_(\\d+)_(.*)"
) %>%
# --- Step C: Create ID and Cleanup ---
mutate(
trial_id = paste(subset_id, object, digit, sep = "_")
)
View(decoder_key)
decoder_key <- master_df %>%
# --- Step A: Rename "Idea" columns to match the pattern ---
# matches("^[a-z]+_\\d+$") finds columns like 'brick_1' but ignores 'brick_1_Condition'
rename_with(
.fn = ~paste0(., "_Text"),
.cols = matches("^[a-z]+_\\d+$")
) %>%
# --- Step B: Pivot everything at once ---
# We use a regex pattern to split the column names into 3 parts:
# 1. Object (brick)  2. Digit (1)  3. Type (Text or Condition)
pivot_longer(
cols = -subset_id,
names_to = c("object", "digit", ".value"),
names_pattern = "(.*)_(\\d+)_(.*)"
) %>%
# --- Step C: Create ID and Cleanup ---
mutate(
trial_id = paste(subset_id, object, digit, sep = "_")
) %>%
rename(idea_text = Text,
submitter_condition = Condition)
condition_ratings <- left_join(ratings_long, decoder_key, by="trial_id")
# 46 of the 52 remaining subset IDs have been rated
condition_ratings_2 <- left_join(ratings_2_long, decoder_key, by="trial_id")
individual_ratings <- rbind(condition_ratings, condition_ratings_2) %>%
select(participantId, subset_ids_DO, trial_id:submitter_condition) %>%
rename(subset_id = subset_ids_DO)
View(condition_ratings)
condition_ratings <- full_join(ratings_long, decoder_key, by="trial_id")
condition_ratings <- left_join(ratings_long, decoder_key, by="trial_id")
condition_ratings <- left_join(ratings_long, decoder_key, by=c("trial_id", "submitter_id"))
View(ratings_3_long)
View(ratings_long)
# Merge rating data with the information about where the idea came from
decoder_key <- master_df %>%
# --- Step A: Rename "Idea" columns to match the pattern ---
# matches("^[a-z]+_\\d+$") finds columns like 'brick_1' but ignores 'brick_1_Condition'
rename_with(
.fn = ~paste0(., "_Text"),
.cols = matches("^[a-z]+_\\d+$")
) %>%
# --- Step B: Pivot everything at once ---
# We use a regex pattern to split the column names into 3 parts:
# 1. Object (brick)  2. Digit (1)  3. Type (Text or Condition)
pivot_longer(
cols = -subset_id,
names_to = c("object", "digit", ".value"),
names_pattern = "(.*)_(\\d+)_(.*)"
) %>%
# --- Step C: Create ID and Cleanup ---
mutate(
trial_id = paste(subset_id, object, digit, sep = "_")
) %>%
select(trial_id, idea_text = Text, submitter_condition = Condition)
condition_ratings <- left_join(ratings_long, decoder_key, by="trial_id")
# 46 of the 52 remaining subset IDs have been rated
condition_ratings_2 <- left_join(ratings_2_long, decoder_key, by="trial_id")
# Bind rows
individual_ratings <- rbind(condition_ratings, condition_ratings_2) %>%
select(participantId, subset_ids_DO, trial_id:submitter_condition) %>%
rename(subset_id = subset_ids_DO)
condition_ratings_3 <- left_join(ratings_3_long, decoder_key, by="trial_id") %>%
rename(subset_id = "subset_ids_DO") %>%
select(participantId, subset_id, trial_id:submitter_condition)
# Bind rows
all_ratings <- rbind(individual_ratings, condition_ratings_3)
all_ratings_wide <- all_ratings %>%
select(-rating) %>%
pivot_wider(
names_from = "metric",
values_from = "rating_num")
# Merge with submitters' demographic data
all_ratings_demographics <- left_join(all_ratings_wide, df_processed_demographics)
View(all_ratings_wide)
demographics_clean <- master_df %>%
# 1. Pivot Longer: Break the column headers apart
pivot_longer(
cols = everything(), # Or select specific columns if ID is separate
names_to = c("trial_id", ".value"),
names_pattern = "(.*)_(.*)"
)
demographics_clean <- master_df %>%
select(-subset_id) %>%
pivot_longer(
cols = everything(), # Or select specific columns if ID is separate
names_to = c("trial_id", ".value"),
names_pattern = "(.*)_(.*)"
)
View(demographics_clean)
# Merge with submitters' demographic data
demographics_clean <- master_df %>%
select(-subset_id) %>%
pivot_longer(
cols = everything(), # Or select specific columns if ID is separate
names_to = c("trial_id", ".value"),
names_pattern = "(.*)_([^_]+)$"
)
View(demographics_clean)
demographics_clean <- master_df %>%
pivot_longer(
cols = brick_1:frisbee_5,
names_to = c("trial_id"),
values_to = "idea_text"
)
View(demographics_clean)
demographics_clean <- master_df %>%
rename_with(
.fn = ~ paste0(., "_idea_text"),  # The function: add suffix to the name
.cols = brick_1:frisbee_5         # The columns to apply it to
)
View(demographics_clean)
master_long <- master_df %>%
pivot_longer(
# Only pivot the columns that follow your trial pattern
# (Safe if you have a participant ID column you don't want to mess up)
cols = matches("brick|frisbee|bubblewrap"),
# '.value' tells R: "Use the second group to make new column headers"
names_to = c("trial_id", ".value"),
# The Regex Magic:
# ^([^_]+_[^_]+) -> Start at beginning, grab (text_text) as Group 1 (trial_id)
# _              -> Skip the underscore separator
# (.*)           -> Grab everything else as Group 2 (the column name)
names_pattern = "^([^_]+_[^_]+)_(.*)"
)
View(master_long)
master_long <- master_df %>%
pivot_longer(
# Only pivot the columns that follow your trial pattern
# (Safe if you have a participant ID column you don't want to mess up)
cols = matches("brick|frisbee|bubblewrap"),
# '.value' tells R: "Use the second group to make new column headers"
names_to = c("trial_id", ".value"),
# The Regex Magic:
# ^([^_]+_[^_]+) -> Start at beginning, grab (text_text) as Group 1 (trial_id)
# _              -> Skip the underscore separator
# (.*)           -> Grab everything else as Group 2 (the column name)
names_pattern = "^([^_]+_[^_]+)_(.*)"
) %>%
drop_na(trial_id)
View(trials)
master_long <- master_df %>%
pivot_longer(
# Only pivot the columns that follow your trial pattern
# (Safe if you have a participant ID column you don't want to mess up)
cols = matches("brick|frisbee|bubblewrap"),
# '.value' tells R: "Use the second group to make new column headers"
names_to = c("trial_id", ".value"),
# The Regex Magic:
# ^([^_]+_[^_]+) -> Start at beginning, grab (text_text) as Group 1 (trial_id)
# _              -> Skip the underscore separator
# (.*)           -> Grab everything else as Group 2 (the column name)
names_pattern = "^([^_]+_[^_]+)_(.*)"
) %>%
drop_na(trial_id) %>%
unite(col = "trial_id",
c(subset_id, trial_id))
View(master_long)
View(df_processed_demographics)
View(all_ratings_wide)
all_ratings_demographics <- left_join(all_ratings_wide, master_long, by="trial_id")
View(all_ratings_demographics)
individual_creativity_mod <- lmer(creative ~ submitter_condition + as.factor(White) + as.factor(gender) + scale(age) + (1 | submitter_id))
individual_creativity_mod <- lmer(creative ~ submitter_condition + as.factor(White) + as.factor(gender) + scale(age) + (1 | submitter_id), data = all_ratings_demographics)
sjPlot::tab_model(individual_creativity_mod)
individual_originality_mod <- lmer(original ~ submitter_condition + as.factor(White) + as.factor(gender) + scale(age) + (1 | submitter_id), data = all_ratings_demographics)
sjPlot::tab_model(individual_originality_mod)
individual_usefulness_mod <- lmer(useful ~ submitter_condition + as.factor(White) + as.factor(gender) + scale(age) + (1 | submitter_id), data = all_ratings_demographics)
sjPlot::tab_model(individual_usefulness_mod)
